------------------------------------------------------------------------
パズル「ナンプレ」の整数計画法による解法について
                                作成  2009/06/13(土)
------------------------------------------------------------------------

1. 目的
  ・整数計画法を応用して、パズル「ナンプレ」の解法を研究することを目的
    とする。

  ・「ナンプレ」は「ナンバープレイス」の略で、ルールに則って 9×9 のマ
    スに1から9の数字を埋めるパズルである。
    「ナンプレ」の解法は、既に入っている数字から、空いているマスに入れ
    られる数字を限定・確定していく方法が一般的である。
  ・これに対して、目先の違う方法として、整数計画法による解法を研究する。


2. 検討の過程
2.1 課題の整理
(1) 「ナンプレ」のルール
  ・ナンプレのルールは下記のとおりである。
    - 空いているマスに1～9のいずれかの数字を入れる。 
    - 縦・横の各列及び、太線で囲まれた3×3のブロック内に同じ数字が複数
      入ってはいけない。
    ※Wikipedia (http://ja.wikipedia.org/wiki/%E6%95%B0%E7%8B%AC) より引用。

(2) 整数計画法の適用にあたっての論点
  ・整数計画法は、変数に対する「制約条件」と「目的関数」が与えられた時
    に、「制約条件」の下で変数の値を変動させ、「目的関数」の値が最大も
    しくは最小となる変数値の組を求めるものである。
  ・従って、何を「変数」として、如何に「制約条件」と「目的関数」を定義
    するかが検討すべき課題である。
    逆の見方をすると、「制約条件」「目的関数」を定義しやすいよう「変数」
    を定義することが肝要である。

2.2 過程1: 「制約条件」の整理
(1) ナンプレの「ルール」
  ・ナンプレを解くにあたっての制約条件はルールそのものである。即ち、下
    記の3種類である。
      - 横軸方向に同じ数字は入らない
      - 縦軸方向に同じ数字は入らない
      - 3×3のブロック内に同じ数字は入らない

(2) ナンプレの「数字の初期配置」
  ・ナンプレの問題として与えられる「数字の初期配置」も、「特定のマスに
    入る数字が決定されている」という観点から「制約条件」と考えることが
    できる。

2.3 過程2: 「変数」の検討
(1) 2次元配列として捉える
  ・ナンプレの盤の形状から単純な類推で考えられるのは、下記の2次元配列
    である。
      X[i][j] = 1～9  (マスに入る数字)
        i: 横軸 1～9
        j: 縦軸 1～9

  ・こうすると、「jを固定して考えることで『横軸方向に同じ数字は入らな
    い』ルールを記述できそう」「iを固定して考えることで『縦軸方向に同
    じ数字は入らない』ルールを記述できそう」と期待する。
    しかし、「3×3のブロック内に同じ数字は入らない」ルールを記述するの
    は少し面倒になりそうである。

(2) 4次元配列として捉える
  ・「3×3のブロック内に同じ数字は入らない」ルールを簡潔に記述するため
    に、下記の4次元配列を考える。
      X[i][j][k][l] = 1～9  (マスに入る数字)
        i: 横方向のブロック番号 1～3
        j: ブロック内の横方向のマス番号 1～3
           →「(i - 1) * 3 + j」で2次元配列の場合の座標値 (横軸) を計算できる。
        k: 縦方向のブロック番号 1～3
        l: ブロック内の縦方向のマス番号 1～3
           →「(k - 1) * 3 + l」で2次元配列の場合の座標値 (縦軸) を計算できる。

  ・これにより、下記の要領でルールを簡潔に記述できると期待できる。
      - (k, l) を固定する: 横軸方向に同じ数字は入らない
      - (i, j) を固定する: 縦軸方向に同じ数字は入らない
      - (i, k) を固定する: 3×3のブロック内に同じ数字は入らない

  ・しかし、「同じ数字は入らない」ルールを数式化するには、変数値に対す
    る判定が発生してしまうため、このままでは整数計画法を適用できない。

(3) 盤面を層で捉える
  ・「変数値に対する判定が発生するのを抑える」の観点から、そもそもの変
    数を「0または1」の二値で表現できるかを検討する。
  ・「マス X[i][j][k][l] に数字Nが入っている」状態を、配列の次元を一つ
    増やして下記のように表現する。
      X[i][j][k][l][m] = 1  (m == N)
                         0  (m != N)
    イメージとしては、数字 m ごとに各マスに当該数字が入っている (1) か
    入っていないか (0) を表す層を持ち、その層を9層重ねることでナンプレ
    の盤面を形成する、と捉えることができる。

  ・この形で盤面の状態を定義すると、「同じ数字は入らない」のルールは、
    一つのマスだけ 1 で他は 0 なので、「全部足して1」という一次式で表
    すことができる。

  ・尚、既に挙げた「制約条件」に加えて、層方向の条件も追加で必要になる。
    それは、「どのマスにも何らかの数字が入っている」ことを要求する制約
    である。これも、一つの数字だけ 1 で他は 0 なので、「全部足して1」
    とい一次式で表すことができる。

2.4 過程3: 「制約条件」を定式化する
(1) 「ナンプレ」のルール
  ・「横軸方向に同じ数字は入らない」
      全ての k, l, m に対して、
         3   3
        Σ  Σ  X[i][j][k][l][m] = 1
        i=1 j=1

  ・「縦軸方向に同じ数字は入らない」
      全ての i, j, m に対して、
         3   3
        Σ  Σ  X[i][j][k][l][m] = 1
        k=1 l=1

  ・「3×3のブロック内に同じ数字は入らない」
      全ての i, k, m に対して、
         3   3
        Σ  Σ  X[i][j][k][l][m] = 1
        j=1 l=1

(2) ナンプレの「数字の初期配置」
  ・初期配置に応じて、下記を制約条件として追加する。
    「横 s 縦 t のマスに数字 u が入っている」場合、

        X[(s-1)/3 + 1][(s-1)%3 + 1][(t-1)/3 + 1][(t-1)%3 + 1][u] = 1

(3) 変数の定義による「層方向の条件」
  ・「どのマスにも何らかの数字が入っている」ことを要求する制約条件。
      全ての i, j, k, l に対して、
         9
        Σ  X[i][j][k][l][m] = 1
        m=1

2.5 過程4: 「目的関数」を定式化する
(1) ふりかえり
  ・与えられた前提や制約は、全て「制約条件」として定義した。むしろ、全
    ての前提や制約を定式化したので、「目的関数」として定義すべき前提や
    制約が残っていない。
  ・改めて、「目的関数」を定義するために、前提や制約を見直す。

(2) 何を「目的関数」とするか
  ・何を「目的関数」とするかを考えるために、「制約条件」でなければなら
    ないものが何かを考える。

  ・まず、「ナンプレ」のルールに起因するものは、「制約条件」であるべき
    と考える。また、変数の定義によって発生した条件も「制約条件」でなけ
    ればならない。
    そうすると、残るは、ナンプレの「数字の初期配置」である。これを「目
    的関数」として定義できるかを検討する。

  ・初期配置の前提なしで、単にルールに則って数字を配置するのであれば、
    多くの解答がある。そこで、複数ある解答の中から最も「数字の初期配置」
    に近いものを求めることが出来れば、それが問題に対する解答と言える。
    この考え方で、「目的関数」を定義する。

(3) 「目的関数」の定義
  ・「横 s 縦 t のマスに数字 u が入っている」場合、
      X[(s-1)/3 + 1][(s-1)%3 + 1][(t-1)/3 + 1][(t-1)%3 + 1][u] = 1

  ・これを踏まえ「数字の初期配置」との近さを下記で定義する。この時、最
    大値は初期配置の数字の数になる。

           Σ          X[(s-1)/3 + 1][(s-1)%3 + 1][(t-1)/3 + 1][(t-1)%3 + 1][u]
    (s,t,u)∈初期配置


3. 整数計画法による解法のまとめ
(1) 変数

    X[i][j][k][l][m] = 0 または 1
      i: 横方向のブロック番号 1～3
      j: ブロック内の横方向のマス番号 1～3
         →「(i - 1) * 3 + j」で2次元配列の場合の座標値 (横軸) を計算できる。
      k: 縦方向のブロック番号 1～3
      l: ブロック内の縦方向のマス番号 1～3
         →「(k - 1) * 3 + l」で2次元配列の場合の座標値 (縦軸) を計算できる。
      m: マスに入る数字

(2) 制約条件
  ・「横軸方向に同じ数字は入らない」
      全ての k, l, m に対して、
         3   3
        Σ  Σ  X[i][j][k][l][m] = 1
        i=1 j=1

  ・「縦軸方向に同じ数字は入らない」
      全ての i, j, m に対して、
         3   3
        Σ  Σ  X[i][j][k][l][m] = 1
        k=1 l=1

  ・「3×3のブロック内に同じ数字は入らない」
      全ての i, k, m に対して、
         3   3
        Σ  Σ  X[i][j][k][l][m] = 1
        j=1 l=1

  ・「どのマスにも何らかの数字が入っている」
      全ての i, j, k, l に対して、
         9
        Σ  X[i][j][k][l][m] = 1
        m=1

(3) 目的関数
  ・下記 (「初期配置との近さ」) を「最大化」する。

           Σ          X[(s-1)/3 + 1][(s-1)%3 + 1][(t-1)/3 + 1][(t-1)%3 + 1][u]
    (s,t,u)∈初期配置

    [注] s: 横軸 1～9、t: 縦軸 1～9、u: 数字 1～9

以上。
